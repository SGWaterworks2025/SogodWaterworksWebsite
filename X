/**
 * Main worker: 
 *  • Reads form responses (coercing values into Dates),
 *  • Updates the Form’s "Date of Appointment" dropdown,
 *  • Syncs per-day summary events on Calendar,
 *  • Writes an Availability table into a sheet.
 * Retention Policy: filters out form responses older than RESPONSE_RETENTION_DAYS days.
 * Constants:
 *  • SLOT_CAP: maximum appointments per day.
 *  • RESPONSE_RETENTION_DAYS: days to retain form responses.
 *  • FULL_SUMMARY_TAG: combined tag for identifying summary events.
 *  • CACHE counts entries expire after 300 seconds (5 minutes).
 * Testing: verify cap reached edge cases and color-coding.
 * Holidays excluded via `HOLIDAY_CAL_ID`.
 */
const SCRIPT_VERSION = 'v2';
const CACHE_KEY = SCRIPT_VERSION + '_counts';
const IS_DEV = false;
const FORM_REGISTRY = [
  {
    formId: '1a7K-SKOU5n3mYlCMM7y0bUqvaO_u5LHtDDS3eLq3mhs',
    sheetName: 'Form Responses 1',
    spreadsheetId: '1SZqf77i655xHA1FI6YzeZ332E6M4Y_dpFmz_h1tM6xQ',
    availabilitySheetName: 'Availability_Form1'
  },
  {
    formId: '1AGsTaMbhv-aCR_B7fEJZ534jwdcHhxB4HcreOfj6Dq0',
    sheetName: 'ForConnection',
    spreadsheetId: '1SZqf77i655xHA1FI6YzeZ332E6M4Y_dpFmz_h1tM6xQ',
    availabilitySheetName: 'Availability_Connection'
  },
  {
    formId: '1sCsIcymP-cIJK7ziMPA_tjWph5ER62n5nscJl3qyEo4',
    sheetName: 'ForDisconnection',
    spreadsheetId: '1SZqf77i655xHA1FI6YzeZ332E6M4Y_dpFmz_h1tM6xQ',
    availabilitySheetName: 'Availability_Disconnection'
  },
  {
    formId: '1lfrpxChZ6K1vvO4-v--ww7nWzT5yIyXqeX2PYr5aBpg',
    sheetName: 'ForReconnection',
    spreadsheetId: '1SZqf77i655xHA1FI6YzeZ332E6M4Y_dpFmz_h1tM6xQ',
    availabilitySheetName: 'Availability_Reconnection'
  },
  {
    formId: '16pTBxWONNrs4jUb_EXmXKyLkglSjYT7I6S2BZaPIPu4',
    sheetName: 'ForRepairandMaintenance',
    spreadsheetId: '1SZqf77i655xHA1FI6YzeZ332E6M4Y_dpFmz_h1tM6xQ',
    availabilitySheetName: 'Availability_Repair'
  },
  {
    formId: '19acXAZfOnMunLOg9enl9JrSJCfzjqbqwn45_QD9vX4g',
    sheetName: 'ForOtherConcerns',
    spreadsheetId: '1SZqf77i655xHA1FI6YzeZ332E6M4Y_dpFmz_h1tM6xQ',
    availabilitySheetName: 'Availability_Other'
  }  /* add remaining form entries here */
];

// Fast-fail if registry entries are malformed
FORM_REGISTRY.forEach(entry => {
  if (!entry.formId || !entry.sheetName) {
    throw new Error('Invalid FORM_REGISTRY entry: ' + JSON.stringify(entry));
  }
});

// Event color constants
const EVENT_COLOR_AVAILABLE = CalendarApp.EventColor.GREEN;
const EVENT_COLOR_FULL      = CalendarApp.EventColor.RED;

const SLOT_CAP = 20;
const RESPONSE_RETENTION_DAYS = 90;
const TZ = Session.getScriptTimeZone();
const THROTTLE_INTERVAL_MS = 60000;
const LOCK_TIMEOUT_MS = 30000;
const TAG_SUMMARY = '##SLOT_SUMMARY##';
const TAG_APPOINTMENT = 'Appointment:';
const CAL = CalendarApp.getDefaultCalendar();

// Module-level spreadsheet cache
let spreadsheetCache = {};

const MAX_ADVANCE_DAYS = 60;
const BUSINESS_DAYS_WINDOW = 60;
const EMAIL_THROTTLE_MS = 24 * 60 * 60 * 1000;
const SUMMARY_TAG_PREFIX = '[SYSTEM_GEN]';
const FULL_SUMMARY_TAG = SUMMARY_TAG_PREFIX + TAG_SUMMARY;

/**
 * Tag used to identify holiday mirror events.
 */
const TAG_HOLIDAY = SUMMARY_TAG_PREFIX + '##HOLIDAY##';
const CHUNK_SIZE = 50;
const CACHE = CacheService.getScriptCache();


const HOLIDAY_CAL_ID = 'en.philippines#holiday@group.v.calendar.google.com';
const HOLIDAY_CACHE_KEY = SCRIPT_VERSION + '_holidays';
const HOLIDAY_CACHE_TTL = 12 * 60 * 60;

// Module-level throttle state
const propsEmail = PropertiesService.getScriptProperties();

// Module-level cache for form list items (per form ID)
let cachedListItems = {};
let cachedCounts = null;

/**
 * Centralized holiday service with fallback mechanisms
 */
const HolidayService = {
  _holidayCalendar: null,
  _initialized: false,
  _calendarAvailable: false,
  _manualHolidays: [
    { month: 1, day: 1 },   // New Year's Day
    { month: 4, day: 9 },   // Araw ng Kagitingan
    { month: 5, day: 1 },   // Labor Day
    { month: 6, day: 12 },  // Independence Day
    { month: 8, day: 21 },  // Ninoy Aquino Day
    { month: 11, day: 1 },  // All Saints' Day
    { month: 11, day: 2 },  // All Souls' Day
    { month: 11, day: 30 }, // Bonifacio Day
    { month: 12, day: 8 },  // Feast of the Immaculate Conception
    { month: 12, day: 25 }, // Christmas Day
    { month: 12, day: 30 }, // Rizal Day
    { month: 12, day: 31 }  // New Year's Eve
  ],

  /**
   * Calculate National Heroes Day (last Monday of August)
   * @param {number} year - The year to calculate for
   * @return {Date} The National Heroes Day date
   */
  getNationalHeroesDay(year) {
    // Start from August 31 and work backwards to find the last Monday
    let date = new Date(year, 7, 31); // August 31 (month is 0-indexed)
    while (date.getDay() !== 1) { // 1 = Monday
      date.setDate(date.getDate() - 1);
    }
    return date;
  },

  /**
   * Initialize the holiday calendar instance and test access
   */
  initHolidayCalendar() {
    if (this._initialized) return;
    
    try {
      this._holidayCalendar = CalendarApp.getCalendarById(HOLIDAY_CAL_ID);
      // Test access by trying to get events for a small range
      const testStart = new Date();
      const testEnd = new Date(testStart.getTime() + 86400000); // +1 day
      this._holidayCalendar.getEvents(testStart, testEnd);
      this._calendarAvailable = true;
      logTS('HolidayService: Calendar access verified');
    } catch (e) {
      this._calendarAvailable = false;
      logTS('HolidayService: Calendar access failed, will use fallbacks: ' + e);
    }
    
    this._initialized = true;
  },

  /**
   * Fetch holiday dates for a range with fallback mechanisms
   * @param {Date} startDate - Start date
   * @param {Date} endDate - End date
   * @return {Set<string>} Set of holiday date strings in yyyy-MM-dd format
   */
  fetchRange(startDate, endDate) {
    this.initHolidayCalendar();
    
    const startStr = DateUtils.formatYMD(startDate);
    const endStr = DateUtils.formatYMD(endDate);
    const cacheKey = `${SCRIPT_VERSION}_holidays_${startStr}_${endStr}`;
    
    // Check cache first
    const cached = safeCacheGet(cacheKey);
    if (cached) {
      try {
        const dates = JSON.parse(cached);
        logTS(`HolidayService: cache hit for range ${startStr} to ${endStr}`);
        return new Set(dates);
      } catch (e) {
        logTS('HolidayService: cache parse error: ' + e);
      }
    }
    
    let dates = [];
    
    // Try CalendarApp first
    if (this._calendarAvailable) {
      try {
        const events = this._holidayCalendar.getEvents(startDate, endDate);
        dates = events.map(ev => DateUtils.formatYMD(ev.getStartTime()));
        logTS(`HolidayService: CalendarApp fetched ${dates.length} holidays`);
      } catch (e) {
        logTS('HolidayService: CalendarApp fetch failed: ' + e);
        this._calendarAvailable = false;
        dates = [];
      }
    }
    
    // Fallback to ICS feed if CalendarApp failed
    if (dates.length === 0 && !this._calendarAvailable) {
      try {
        const icsUrl = 'https://calendar.google.com/calendar/ical/en.philippines%23holiday%40group.v.calendar.google.com/public/basic.ics';
        
        try {
          const response = UrlFetchApp.fetch(icsUrl);
          const icsContent = response.getContentText();
          
          // Parse DTSTART lines from ICS content
          const dtStartRegex = /DTSTART;VALUE=DATE:(\d{4})(\d{2})(\d{2})/g;
          let match;
          const icsHolidays = [];
          
          while ((match = dtStartRegex.exec(icsContent)) !== null) {
            const year = parseInt(match[1], 10);
            const month = parseInt(match[2], 10);
            const day = parseInt(match[3], 10);
            const holidayDate = DateUtils.buildDate(year, month, day);
            
            // Only include holidays within our date range
            if (holidayDate >= startDate && holidayDate <= endDate) {
              icsHolidays.push(DateUtils.formatYMD(holidayDate));
            }
          }
          
          dates = icsHolidays;
          logTS(`HolidayService: ICS fallback fetched ${dates.length} holidays`);
        } catch (fetchError) {
          logTS('HolidayService: UrlFetchApp.fetch failed: ' + fetchError);
          dates = [];
        }
      } catch (e) {
        logTS('HolidayService: ICS fallback error: ' + e);
        dates = [];
      }
    }
    
    // Final fallback to manual recurring rules
    if (dates.length === 0) {
      const manualHolidays = [];
      const startYear = startDate.getFullYear();
      const endYear = endDate.getFullYear();
      
      for (let year = startYear; year <= endYear; year++) {
        this._manualHolidays.forEach(holiday => {
          const holidayDate = DateUtils.buildDate(year, holiday.month, holiday.day);
          if (holidayDate >= startDate && holidayDate <= endDate) {
            manualHolidays.push(DateUtils.formatYMD(holidayDate));
          }
        });
      }
      
      dates = manualHolidays;
      logTS(`HolidayService: Manual rules generated ${dates.length} holidays`);
    }
    
    // Cache the results
    safeCachePut(cacheKey, JSON.stringify(dates), HOLIDAY_CACHE_TTL);
    return new Set(dates);
  },

  /**
   * Check if a specific date is a holiday
   * @param {string|Date} dateInput - Date string in yyyy-MM-dd format or Date object
   * @return {boolean} True if holiday, false otherwise (defaults to true on error)
   */
  isHoliday(dateInput) {
    try {
      this.initHolidayCalendar();
      
      let date;
      if (dateInput instanceof Date) {
        date = dateInput;
      } else {
        date = DateUtils.parseDate(dateInput);
        if (!date) {
          logTS('HolidayService.isHoliday: Invalid date: ' + dateInput);
          return true; // Assume holiday on invalid date
        }
      }
      
      // Try calendar first if available
      if (this._calendarAvailable) {
        try {
          const events = this._holidayCalendar.getEventsForDay(date);
          if (events.length > 0) {
            logTS('HolidayService.isHoliday: confirmed holiday via calendar ' + DateUtils.formatYMD(date));
            return true;
          }
        } catch (e) {
          logTS('HolidayService.isHoliday: calendar error, falling back to manual: ' + e);
          this._calendarAvailable = false;
        }
      }
      
      // Fallback to manual holiday checks
      const month = date.getMonth() + 1; // Convert to 1-12
      const day = date.getDate();
      const year = date.getFullYear();
      
      // Check fixed holidays
      for (const holiday of this._manualHolidays) {
        if (holiday.month === month && holiday.day === day) {
          logTS('HolidayService.isHoliday: confirmed fixed holiday ' + DateUtils.formatYMD(date));
          return true;
        }
      }
      
      // Check National Heroes Day (last Monday of August)
      const nationalHeroesDay = this.getNationalHeroesDay(year);
      if (date.getTime() === nationalHeroesDay.getTime()) {
        logTS('HolidayService.isHoliday: confirmed National Heroes Day ' + DateUtils.formatYMD(date));
        return true;
      }
      
      return false;
    } catch (e) {
      logTS('HolidayService.isHoliday: error checking ' + dateInput + ': ' + e);
      return true; // Assume holiday on error to be safe
    }
  }
};

/**
 * Centralized date utilities for timezone-safe operations
 */
const DateUtils = {
  /**
   * Build a Date object from year, month, day components
   * @param {number} year - Full year
   * @param {number} month - Month (1-12)
   * @param {number} day - Day of month
   * @return {Date} Date object
   */
  buildDate(year, month, day) {
    return new Date(year, month - 1, day);
  },

  /**
   * Format a Date object as yyyy-MM-dd using script timezone
   * @param {Date} date - Date to format
   * @return {string} Formatted date string
   */
  formatYMD(date) {
    return Utilities.formatDate(date, TZ, 'yyyy-MM-dd');
  },

  /**
   * Parse a date string into a Date object
   * @param {string} dateText - Date string in yyyy-MM-dd format
   * @return {Date|null} Date object or null if invalid
   */
  parseDate(dateText) {
    try {
      const match = dateText.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!match) return null;
      
      const year = parseInt(match[1], 10);
      const month = parseInt(match[2], 10);
      const day = parseInt(match[3], 10);
      
      const date = this.buildDate(year, month, day);
      return isNaN(date) ? null : date;
    } catch (e) {
      return null;
    }
  }
};

/**
 * Checks if a given date is a holiday.
 * @param {string} dateText - Date string in yyyy-MM-dd format.
 * @return {boolean} True if the date is a holiday, false otherwise.
 */
function isHoliday_(dateText) {
  try {
    return HolidayService.isHoliday(dateText);
  } catch (e) {
    logTS('isHoliday_: error delegating to HolidayService: ' + e);
    return true; // Assume holiday on error to be safe
  }
}

/**
 * Safely parses a cell value into a date string.
 * @param {*} cell - The cell value to parse.
 * @return {string|null} Date string in yyyy-MM-dd format or null if invalid.
 */
function safeParseDate_(cell) {
  try {
    if (cell instanceof Date && !isNaN(cell)) {
      return DateUtils.formatYMD(cell);
    }
    const s = String(cell);
    const m = s.match(/(\d{4}-\d{2}-\d{2})/);
    if (m) {
      const testDate = DateUtils.parseDate(m[1]);
      if (testDate) {
        return m[1];
      }
    }
    return null;
  } catch (err) {
    return null;
  }
}

/**
 * Splits an array into chunks of specified size.
 * @param {Array} arr - Array to chunk.
 * @param {number} size - Chunk size.
 * @return {Array[]} Array of chunks.
 */
function chunkArray(arr, size) {
  const chunks = [];
  for (let i = 0; i < arr.length; i += size) {
    chunks.push(arr.slice(i, i + size));
  }
  return chunks;
}

/**
 * Logs a timestamped message to the Logger.
 * @param {string} label - The message to log.
 */
function logTS(label) {
  Logger.log(`[${new Date().toISOString()}] ${label}`);
}

/**
 * Formats a Date object as yyyy-MM-dd.
 * @param {Date} date - The date to format.
 * @return {string} Formatted date string.
 */
function formatYMD_(date) {
  return DateUtils.formatYMD(date);
}

/**
 * Safely puts a value into cache with error handling.
 * @param {string} key - Cache key.
 * @param {string} value - Value to cache.
 * @param {number} ttl - Time to live in seconds.
 */
function safeCachePut(key, value, ttl) {
  try {
    CACHE.put(key, value, ttl);
  } catch (e) {
    logTS('safeCachePut error: ' + e);
  }
}

/**
 * Safely gets a value from cache with error handling and logging.
 * @param {string} key - Cache key.
 * @return {string|null} Cached value or null if not found/error.
 */
function safeCacheGet(key) {
  try {
    const value = CACHE.get(key);
    if (value) {
      logTS('cache hit: ' + key);
      return value;
    } else {
      logTS('cache miss: ' + key);
      return null;
    }
  } catch (e) {
    logTS('safeCacheGet error: ' + e);
    return null;
  }
}

/**
 * Safely removes a value from cache with error handling.
 * @param {string} key - Cache key to remove.
 */
function safeCacheRemove(key) {
  try {
    CACHE.remove(key);
    logTS('cache removed: ' + key);
  } catch (e) {
    logTS('safeCacheRemove error: ' + e);
  }
}

/**
 * Retrieves holiday dates between two dates (inclusive) and caches them.
 * @param {Date} startDate - Start date.
 * @param {Date} endDate - End date.
 * @return {Set<string>} Set of holiday date strings in yyyy-MM-dd format.
 */
function getHolidayDates(startDate, endDate) {
  return HolidayService.fetchRange(startDate, endDate);
}

/**
 * Removes summary events and appointment events that fall on holiday dates within the specified range.
 * @param {Date} startDate - Start date for the range.
 * @param {Date} endDate - End date for the range.
 */
function removeHolidaySummaries(startDate, endDate) {
  logTS('removeHolidaySummaries:start');
  const holidaySet = getHolidayDates(startDate, endDate);
  const summariesToDelete = [];
  const appointmentsToDelete = [];
  
  holidaySet.forEach(dateText => {
    const [y, m, d] = dateText.split('-').map(Number);
    const dayDate = new Date(y, m - 1, d);
    const dayEvents = CAL.getEventsForDay(dayDate);
    
    // Collect summary events on holidays
    const summaries = dayEvents.filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
    summariesToDelete.push(...summaries);
    
    // Collect appointment events on holidays
    const appointments = dayEvents.filter(ev => ev.getTitle().startsWith(TAG_APPOINTMENT));
    appointmentsToDelete.push(...appointments);
  });
  
  // Delete summary events in chunks
  chunkArray(summariesToDelete, CHUNK_SIZE).forEach(chunk => {
    try { 
      chunk.forEach(ev => ev.deleteEvent()); 
      logTS(`Deleted ${chunk.length} holiday summary events`);
    }
    catch(e){ 
      logTS('Chunk delete error in removeHolidaySummaries (summaries): '+e); 
    }
  });
  
  // Delete appointment events in chunks
  chunkArray(appointmentsToDelete, CHUNK_SIZE).forEach(chunk => {
    try { 
      chunk.forEach(ev => ev.deleteEvent()); 
      logTS(`Deleted ${chunk.length} holiday appointment events`);
    }
    catch(e){ 
      logTS('Chunk delete error in removeHolidaySummaries (appointments): '+e); 
    }
  });
  
  logTS('removeHolidaySummaries:end');
}

/**
 * Sends throttled error emails to avoid spam.
 * @param {string} functionName - Name of the function that errored.
 * @param {*} err - The error object or message.
 */
function sendThrottledError(functionName, err) {
  try {
    if (IS_DEV) {
      FormApp.getUi().alert(String(err));
    } else {
      const lastEmail = parseInt(propsEmail.getProperty('LAST_ERROR_EMAIL_TS')||'0',10);
      const now = Date.now();
      if(now - lastEmail >= EMAIL_THROTTLE_MS) {
        propsEmail.setProperty('LAST_ERROR_EMAIL_TS',String(now));
        const subject = `Error @ ${new Date().toISOString()} - ${functionName}`;
        MailApp.sendEmail(Session.getEffectiveUser().getEmail(), subject, String(err));
      }
    }
  } catch (e) {
    logTS('sendThrottledError failed: ' + e);
  }
}

/**
 * Gets spreadsheet for a registry entry, with caching and fallback.
 * @param {Object} entry - Registry entry with spreadsheetId.
 * @return {Spreadsheet} The spreadsheet object.
 */
function getSpreadsheetForEntry(entry) {
  if (!entry.spreadsheetId) {
    logTS(`getSpreadsheetForEntry: No spreadsheetId for entry ${entry.sheetName}, falling back to active spreadsheet`);
    return SpreadsheetApp.getActiveSpreadsheet();
  }
  
  if (spreadsheetCache[entry.spreadsheetId]) {
    return spreadsheetCache[entry.spreadsheetId];
  }
  
  try {
    const ss = SpreadsheetApp.openById(entry.spreadsheetId);
    spreadsheetCache[entry.spreadsheetId] = ss;
    return ss;
  } catch (e) {
    logTS(`getSpreadsheetForEntry: Failed to open spreadsheet ${entry.spreadsheetId} for ${entry.sheetName}: ${e}`);
    logTS(`getSpreadsheetForEntry: Falling back to active spreadsheet`);
    return SpreadsheetApp.getActiveSpreadsheet();
  }
}

/**
 * Gets or creates a sheet in the specified spreadsheet.
 * @param {Spreadsheet} spreadsheet - The spreadsheet object.
 * @param {string} sheetName - Name of the sheet.
 * @return {Sheet} The sheet object.
 */
function getOrCreateSheetInSpreadsheet(spreadsheet, sheetName) {
  let sheet = spreadsheet.getSheetByName(sheetName);
  if (!sheet) {
    sheet = spreadsheet.insertSheet(sheetName);
  }
  return sheet;
}

/**
 * Ensures all sheets in FORM_REGISTRY exist, creating them if necessary.
 */
function ensureSheetsExist() {
  logTS('ensureSheetsExist:start');
  FORM_REGISTRY.forEach(entry => {
    try {
      const ss = getSpreadsheetForEntry(entry);
      
      // Ensure form response sheet exists
      const sheet = getOrCreateSheetInSpreadsheet(ss, entry.sheetName);
      
      // Initialize headers if the sheet is new (first row is empty)
      const lastRow = sheet.getLastRow();
      if (lastRow === 0 || (lastRow === 1 && sheet.getRange(1, 1).getValue() === '')) {
        const headers = ['Timestamp', 'Last Name', 'First Name', 'Purok', 'Barangay', 'Date of Appointment'];
        sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
        logTS(`Initialized headers for ${entry.sheetName}`);
      }
      
      logTS(`Ensured sheet exists: ${entry.sheetName}`);
      
      // Ensure availability sheet exists
      const availSheet = getOrCreateSheetInSpreadsheet(ss, entry.availabilitySheetName);
      
      // Initialize headers if the sheet is new (first row is empty)
      const availLastRow = availSheet.getLastRow();
      if (availLastRow === 0 || (availLastRow === 1 && availSheet.getRange(1, 1).getValue() === '')) {
        const headers = ['Date', 'Booked', 'Slots Left'];
        availSheet.getRange(1, 1, 1, headers.length).setValues([headers]);
        logTS(`Initialized headers for ${entry.availabilitySheetName}`);
      }
      
      logTS(`Ensured availability sheet exists: ${entry.availabilitySheetName}`);
    } catch (e) {
      logTS(`Error ensuring sheets for entry ${entry.sheetName}: ${e}`);
    }
  });
  
  logTS('ensureSheetsExist:end');
}

/**
 * Links all forms in FORM_REGISTRY to their corresponding sheets in the spreadsheet.
 */
function linkAllFormDestinations() {
  logTS('linkAllFormDestinations:start');
  FORM_REGISTRY.forEach(entry => {
    try {
      const form = FormApp.openById(entry.formId);
      form.setDestination(FormApp.DestinationType.SPREADSHEET, entry.spreadsheetId, entry.sheetName);
      logTS(`Linked form ${entry.formId} to sheet: ${entry.sheetName}`);
    } catch (e) {
      logTS(`Error linking form ${entry.formId} to sheet ${entry.sheetName}: ${e}`);
    }
  });
  logTS('linkAllFormDestinations:end');
}

/**
 * Creates submit triggers for all forms in FORM_REGISTRY.
 */
function createAllSubmitTriggers() {
  logTS('createAllSubmitTriggers:start');
  
  // Remove existing form submit triggers to avoid duplicates
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getEventType() === ScriptApp.EventType.ON_FORM_SUBMIT) {
      try {
        ScriptApp.deleteTrigger(trigger);
        logTS('Removed existing form submit trigger');
      } catch (e) {
        logTS('Error removing trigger: ' + e);
      }
    }
  });
  
  let successCount = 0;
  let skipCount = 0;
  
  // Create new triggers for each form, skipping invalid ones
  FORM_REGISTRY.forEach(entry => {
    try {
      // Validate form ID before creating trigger
      let form;
      try {
        form = FormApp.openById(entry.formId);
      } catch (formError) {
        logTS(`SKIPPING: Invalid form ID ${entry.formId} (${entry.sheetName}) - ${formError}`);
        skipCount++;
        return;
      }
      
      ScriptApp.newTrigger('onFormSubmit')
        .forForm(form)
        .onFormSubmit()
        .create();
      logTS(`Created submit trigger for form: ${entry.formId} (${entry.sheetName})`);
      successCount++;
    } catch (e) {
      logTS(`SKIPPING: Error creating trigger for form ${entry.formId} (${entry.sheetName}): ${e}`);
      skipCount++;
    }
  });
  
  logTS(`createAllSubmitTriggers:end - Created ${successCount} triggers, skipped ${skipCount} invalid forms`);
}

/**
 * Updates date dropdown choices for all forms in FORM_REGISTRY.
 * @param {string[]} choices - Array of choice values.
 */
function updateAllDateDropdowns(choices) {
  logTS('updateAllDateDropdowns:start');
  FORM_REGISTRY.forEach(entry => {
    try {
      const li = getAppointmentListItem_(entry.formId);
      li.setChoiceValues(choices);
      logTS(`Updated dropdown for form: ${entry.formId}`);
    } catch (e) {
      logTS(`Error updating dropdown for form ${entry.formId}: ${e}`);
    }
  });
  logTS('updateAllDateDropdowns:end');
}

/**
 * Updates date dropdown choices for a specific form.
 * @param {string} formId - Form ID to update.
 * @param {string[]} choices - Array of choice values.
 */
function updateDateDropdownForForm(formId, choices) {
  logTS('updateDateDropdownForForm:start');
  try {
    const li = getAppointmentListItem_(formId);
    li.setChoiceValues(choices);
    logTS(`Updated dropdown for form: ${formId}`);
  } catch (e) {
    logTS(`Error updating dropdown for form ${formId}: ${e}`);
  }
  logTS('updateDateDropdownForForm:end');
}

/**
 * Validates that all forms in FORM_REGISTRY have the required "Date of Appointment" list item.
 */
function validateFormListItems() {
  logTS('validateFormListItems:start');
  FORM_REGISTRY.forEach(entry => {
    try {
      const form = FormApp.openById(entry.formId);
      const item = form.getItems(FormApp.ItemType.LIST)
                       .find(i => i.asListItem().getTitle() === 'Date of Appointment');
      if (!item) {
        logTS(`ERROR: Form ${entry.formId} (${entry.sheetName}) missing "Date of Appointment" list item`);
      } else {
        logTS(`Validated "Date of Appointment" list item exists in form: ${entry.formId}`);
      }
    } catch (e) {
      logTS(`Error validating form ${entry.formId}: ${e}`);
    }
  });
  logTS('validateFormListItems:end');
}

/**
 * Validates that all forms in FORM_REGISTRY are accessible.
 * Logs errors for inaccessible forms but continues processing.
 */
function validateFormAccess() {
  logTS('validateFormAccess:start');
  FORM_REGISTRY.forEach(entry => {
    try {
      const form = FormApp.openById(entry.formId);
      logTS(`Validated form access: ${entry.formId} (${entry.sheetName})`);
    } catch (e) {
      logTS(`ERROR: Cannot access form ${entry.formId} (${entry.sheetName}): ${e}`);
    }
  });
  logTS('validateFormAccess:end');
}

/**
 * Validates that all sheets in FORM_REGISTRY have the required header structure.
 * Logs errors for missing headers but continues processing.
 */
function validateSheetStructures() {
  logTS('validateSheetStructures:start');
  const requiredHeaders = ['Last Name', 'First Name', 'Purok', 'Barangay', 'Date of Appointment'];
  
  FORM_REGISTRY.forEach(entry => {
    try {
      const sheet = getOrCreateSheet_(entry.sheetName);
      logTS(`Validating sheet structure: ${entry.sheetName}`);
      
      requiredHeaders.forEach(headerName => {
        try {
          detectColumnIndex_(sheet, headerName);
          logTS(`  ✓ Found header: ${headerName}`);
        } catch (e) {
          logTS(`  ✗ Missing header in ${entry.sheetName}: ${headerName}`);
        }
      });
    } catch (e) {
      logTS(`Error validating sheet structure for ${entry.sheetName}: ${e}`);
    }
  });
  logTS('validateSheetStructures:end');
}

/**
 * Main setup function that initializes all multi-form components.
 */
function runSetup() {
  logTS('runSetup:start');
  try {
    validateFormAccess();
    ensureSheetsExist();
    validateSheetStructures();
    HolidayService.initHolidayCalendar();
    linkAllFormDestinations();
    createAllSubmitTriggers();
    validateFormListItems();
    
    // Initialize dropdowns with current availability
    const dates = getResponseDates();
    const counts = tallyByDate(dates);
    const { choices } = buildBusinessDays(counts);
    updateAllDateDropdowns(choices);
    
    // Initial full sync to populate summaries and sheet
    updateAvailability_everywhere();
    
    logTS('runSetup completed successfully');
  } catch (e) {
    logTS('Error in runSetup: ' + e);
    sendThrottledError('runSetup', e);
  }
  logTS('runSetup:end');
}

/**
 * Performs full availability sync: form, calendar summaries, sheet output.
 */
function updateAvailability_everywhere() {
  try {
    let lock = LockService.getScriptLock();
    if (!lock.tryLock(LOCK_TIMEOUT_MS)) {
      logTS('Lock busy, skipping updateAvailability_everywhere');
      return;
    }
    try {
      // Throttle full sync to once per minute
      const propsSync = PropertiesService.getScriptProperties();
      const nowSync = Date.now();
      const lastSync = parseInt(propsSync.getProperty('LAST_FULL_SYNC_TS') || '0', 10);
      if (nowSync - lastSync < THROTTLE_INTERVAL_MS) {
        logTS('Skipping updateAvailability_everywhere due to throttle');
        return;
      }
      propsSync.setProperty('LAST_FULL_SYNC_TS', String(nowSync));

      logTS('updateAvailability_everywhere:start');
      const dates = getResponseDates();
      let counts = safeCacheGet(CACHE_KEY);
      if (counts) {
        counts = JSON.parse(counts);
      } else {
        counts = tallyByDate(dates);
        safeCachePut(CACHE_KEY, JSON.stringify(counts), 300);
      }
      const { availDates, choices } = buildBusinessDays(counts);
      
      // Filter out any holidays that might have slipped through
      const nonHolidayDates = availDates.filter(dateStr => {
        if (HolidayService.isHoliday(dateStr)) {
          logTS('updateAvailability_everywhere: filtering out holiday ' + dateStr);
          return false;
        }
        return true;
      });
      
      updateAllDateDropdowns(choices);
      batchSyncCalendarSummaries(nonHolidayDates, counts);
      batchWriteAvailabilitySheets(nonHolidayDates, counts);
      // Mirror all holiday dates in the same window
      const windowStart = new Date();
      const windowEnd = new Date();
      windowEnd.setDate(windowEnd.getDate() + BUSINESS_DAYS_WINDOW);
      getHolidayDates(windowStart, windowEnd).forEach(date => upsertHolidayMirror(date));
      safeCacheRemove(CACHE_KEY); // Invalidate cache after full sync
      cachedCounts = null;
      logTS('updateAvailability_everywhere:end');
    } finally {
      lock.releaseLock();
    }
  } catch (err) {
    Logger.log('Error in updateAvailability_everywhere: ' + err);
    sendThrottledError('updateAvailability_everywhere', err);
    throw err;
  }
}

/**
 * Handles Form submit event: creates calendar event and updates counts.
 * @param {Object} e - Form submit event object.
 */
function onFormSubmit(e) {
  try {
    let lock = LockService.getScriptLock();
    if (!lock.tryLock(LOCK_TIMEOUT_MS)) {
      logTS('Lock busy, skipping onFormSubmit');
      return;
    }
    try {
      logTS('onFormSubmit:start');
      if (!e || !e.namedValues || !e.source) {
        logTS('Invalid form submit payload');
        return;
      }
      
      // Detect source form and find corresponding sheet
      const sourceFormId = e.source.getId();
      const registryEntry = FORM_REGISTRY.find(entry => entry.formId === sourceFormId);
      if (!registryEntry) {
        logTS('Form not found in registry: ' + sourceFormId);
        return;
      }
      
      logTS(`Processing submission from form: ${sourceFormId} -> sheet: ${registryEntry.sheetName}`);
      
      // Use namedValues for robust field parsing
      const lastName = e.namedValues['Last Name'] ? e.namedValues['Last Name'][0] : '';
      const firstName = e.namedValues['First Name'] ? e.namedValues['First Name'][0] : '';
      const purok = e.namedValues['Purok'] ? e.namedValues['Purok'][0] : '';
      const barangay = e.namedValues['Barangay'] ? e.namedValues['Barangay'][0] : '';
      const dateChoice = e.namedValues['Date of Appointment'] ? e.namedValues['Date of Appointment'][0] : '';
      
      if (!dateChoice) {
        logTS('No date choice found in form submission');
        return;
      }
      
      const dateText = dateChoice.split(' ')[0];
      const start = DateUtils.parseDate(dateText);
      if (!start) {
        logTS('onFormSubmit: Invalid date format: ' + dateText);
        return;
      }

      // Holiday guard: early exit on holidays before any calendar or form logic
      if (HolidayService.isHoliday(dateText)) {
        logTS('onFormSubmit: booking on holiday rejected: ' + dateText);
        return;
      }

      // Duplicate detection: skip if appointment already exists
      const title = `${TAG_APPOINTMENT} ${lastName}, ${firstName} (${purok}, ${barangay})`;
      const dayEvents = CAL.getEventsForDay(start);
      if (dayEvents.some(ev => ev.getTitle() === title && formatYMD_(ev.getStartTime()) === dateText)) {
        logTS('Duplicate appointment for ' + dateText);
        return;
      }

      // Slot cap guard: abort if max appointments reached
      const appointmentCount = dayEvents.filter(ev => ev.getTitle().startsWith(TAG_APPOINTMENT)).length;
      if (appointmentCount >= SLOT_CAP) {
        logTS('Slot cap reached for ' + dateText);
        if(IS_DEV) FormApp.getUi().alert('Slots full for '+dateText);
        else {
          logTS('Admin notified: slot cap reached');
        }
        return;
      }

      const event = CAL.createAllDayEvent(title, start, {
        description: `Purok: ${purok} — Barangay: ${barangay}`
      });

      // Immediately update the calendar summary for this booking
      // remove direct summary update in favor of microSync
      event.setColor(EVENT_COLOR_AVAILABLE);
      updateAvailability_thisdateonly(dateText, sourceFormId);
      logTS('onFormSubmit:end');
    } finally {
      lock.releaseLock();
    }
  } catch (err) {
    Logger.log('Error in onFormSubmit: ' + err);
    sendThrottledError('onFormSubmit', err);
    throw err;
  }
}

/**
 * Integrity Checker: cleans up old events and form options regularly.
 */
function checkCalendarIntegrity() {
  try {
    let lock = LockService.getScriptLock();
    if (!lock.tryLock(LOCK_TIMEOUT_MS)) {
      logTS('Lock busy, skipping checkCalendarIntegrity');
      return;
    }
    try {
      // Throttle integrity check to once per minute
      const propsInt = PropertiesService.getScriptProperties();
      const nowInt = Date.now();
      const lastInt = parseInt(propsInt.getProperty('LAST_INTEGRITY_TS') || '0', 10);
      if (nowInt - lastInt < THROTTLE_INTERVAL_MS) {
        logTS('Skipping checkCalendarIntegrity due to throttle');
        return;
      }
      propsInt.setProperty('LAST_INTEGRITY_TS', String(nowInt));
      
      logTS('checkCalendarIntegrity:start');
      const dates = getResponseDates();
      const respCount = dates.length;
      const props = PropertiesService.getScriptProperties();
      const lastCount = props.getProperty('LAST_RESPONSE_COUNT');
      if (lastCount && parseInt(lastCount, 10) === respCount) {
        logTS('checkCalendarIntegrity:end');
        return;
      }
      props.setProperty('LAST_RESPONSE_COUNT', String(respCount));
      
      // Remove holiday summaries and appointments within advance window before other cleanup
      const now = new Date();
      removeHolidaySummaries(now, new Date(now.getTime() + MAX_ADVANCE_DAYS * 86400000));
      // After cleanup, re-add holiday mirror events
      const holidayEnd = new Date(now.getTime() + MAX_ADVANCE_DAYS * 86400000);
      getHolidayDates(now, holidayEnd).forEach(dateStr => upsertHolidayMirror(dateStr));
      // Remove past Appointment events
      const yesterdayEnd = getEndOfDay_(new Date(now.getTime() - 24 * 60 * 60 * 1000));
      const pastAppointments = CAL.getEvents(new Date(1970, 0, 1), yesterdayEnd)
        .filter(ev => ev.getTitle().startsWith(TAG_APPOINTMENT));
      chunkArray(pastAppointments, CHUNK_SIZE).forEach(chunk => {
        try { chunk.forEach(ev => ev.deleteEvent()); }
        catch(e){ logTS('Chunk delete error: '+e); }
      });
      // Remove past summary events
      const pastSummaries = CAL.getEvents(new Date(1970, 0, 1), yesterdayEnd)
        .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
      chunkArray(pastSummaries, CHUNK_SIZE).forEach(chunk => {
        try { chunk.forEach(ev => ev.deleteEvent()); }
        catch(e){ logTS('Chunk delete error: '+e); }
      });
      // Delete orphaned upcoming appointments
      const validDates = new Set(dates);
      const rangeEnd = new Date(now);
      rangeEnd.setDate(now.getDate() + 30);
      const upcoming = CAL.getEvents(now, rangeEnd);
      const orphanedEvents = [];
      upcoming.forEach(ev => {
        const title = ev.getTitle();
        if (!title.startsWith(TAG_APPOINTMENT)) return;
        const evDate = formatYMD_(ev.getStartTime());
        if (!validDates.has(evDate)) {
          orphanedEvents.push(ev);
        }
      });
      chunkArray(orphanedEvents, CHUNK_SIZE).forEach(chunk => {
        try { chunk.forEach(ev => ev.deleteEvent()); }
        catch(e){ logTS('Chunk delete error: '+e); }
      });
      const deletedCount = orphanedEvents.length;
      if (deletedCount > 0) {
        // Instead of full sync, just refresh summaries for affected dates
        const affectedDates = new Set();
        orphanedEvents.forEach(ev => {
          const evDate = formatYMD_(ev.getStartTime());
          affectedDates.add(evDate);
        });
        
        // Refresh summaries for affected dates only (within business days window)
        const currentCounts = cachedCounts || tallyByDate(getResponseDates());
        const { availDates } = buildBusinessDays(currentCounts);
        const availDatesSet = new Set(availDates);
        
        affectedDates.forEach(dateStr => {
          // Early exit on holidays before any summary creation
          if (HolidayService.isHoliday(dateStr)) {
            logTS('checkCalendarIntegrity: skipping holiday ' + dateStr);
            return;
          }
          // Only update summaries for dates within the business days window
          if (availDatesSet.has(dateStr)) {
            const used = currentCounts[dateStr] || 0;
            const left = SLOT_CAP - used;
            if (left > 0) { // Only update if date still has availability
              upsertDailySummary(dateStr, left);
            }
          }
        });
      }
      // Prune yesterday's date from each form dropdown
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yStr = formatYMD_(yesterday);
      FORM_REGISTRY.forEach(entry => {
        try {
          const li = getAppointmentListItem_(entry.formId);
          const allVals = li.getChoices().map(c => c.getValue());
          const filtered = allVals.filter(v => !v.startsWith(yStr));
          li.setChoiceValues(filtered);
          logTS(`Pruned yesterday (${yStr}) from form: ${entry.formId}`);
        } catch (e) {
          logTS(`Error pruning yesterday from form ${entry.formId}: ${e}`);
        }
      });
      // Clear per‐form cache after pruning
      cachedListItems = {};
      logTS('checkCalendarIntegrity:end');
    } finally {
      lock.releaseLock();
    }
  } catch (err) {
    Logger.log('Error in checkCalendarIntegrity: ' + err);
    sendThrottledError('checkCalendarIntegrity', err);
    throw err;
  }
}

/**
 * Ensures a "Holiday" all-day event exists with TAG_HOLIDAY and green color.
 * @param {string} dateText - yyyy-MM-dd
 */
function upsertHolidayMirror(dateText) {
  let lock = LockService.getScriptLock();
  if (!lock.tryLock(LOCK_TIMEOUT_MS)) return;
  try {
    if (!HolidayService.isHoliday(dateText)) return;
    const [y,m,d] = dateText.split('-').map(Number);
    const day = new Date(y, m - 1, d);
    // Detect existing holiday mirror events
    const existing = CAL.getEventsForDay(day)
      .filter(ev => ev.getDescription() === TAG_HOLIDAY);
    const title = 'Holiday';
    const color = EVENT_COLOR_AVAILABLE; // use green
    if (existing.length > 0) {
      existing[0].setColor(color);
      if (existing.length > 1) existing.slice(1).forEach(ev => ev.deleteEvent());
    } else {
      CAL.createAllDayEvent(title, day, { description: TAG_HOLIDAY }).setColor(color);
    }
  } finally {
    lock.releaseLock();
  }
}

/** Private Helpers **/

/**
 * Retrieves the ListItem for "Date of Appointment" from specified form.
 * @param {string} formId - Optional form ID. Uses first form in registry if not provided.
 * @return {FormListItem} The list item.
 * @throws If the item is not found.
 */
function getAppointmentListItem_(formId) {
  // Use first form in registry if no formId provided (for backward compatibility)
  const targetFormId = formId || FORM_REGISTRY[0].formId;
  
  if (cachedListItems[targetFormId]) {
    return cachedListItems[targetFormId];
  }
  
  const form = FormApp.openById(targetFormId);
  const item = form.getItems(FormApp.ItemType.LIST)
                   .find(i => i.asListItem().getTitle() === 'Date of Appointment');
  if (!item) throw new Error(`No LIST item titled "Date of Appointment" in form ${targetFormId}`);
  
  cachedListItems[targetFormId] = item.asListItem();
  return cachedListItems[targetFormId];
}

/**
 * Returns a Date set to the end of the given day.
 * @param {Date} date - Base date.
 * @return {Date} Date at 23:59:59.999 of the same day.
 */
function getEndOfDay_(date) {
  const endOfDay = new Date(date);
  endOfDay.setHours(23, 59, 59, 999);
  return endOfDay;
}

/**
 * Reads dates from all form response sheets, filters out old entries.
 * @return {string[]} Array of yyyy-MM-dd date strings from all forms.
 */
function getResponseDates() {
  logTS('getResponseDates:start');
  const allDates = [];
  
  FORM_REGISTRY.forEach(entry => {
    try {
      const ss = getSpreadsheetForEntry(entry);
      const sheet = ss.getSheetByName(entry.sheetName);
      if (!sheet) {
        logTS(`Sheet not found: ${entry.sheetName}`);
        return;
      }
      
      const lastRow = sheet.getLastRow();
      if (lastRow <= 1) {
        logTS(`No data rows in sheet: ${entry.sheetName}`);
        return;
      }
      
      // Use dynamic column detection instead of hardcoded RESP_DATE_COL
      let dateColIdx;
      try {
        dateColIdx = detectColumnIndex_(sheet, 'Date of Appointment');
      } catch (e) {
        logTS(`Skipping sheet ${entry.sheetName} due to missing 'Date of Appointment' column: ${e}`);
        return;
      }
      
      const raw = sheet.getRange(2, dateColIdx, lastRow - 1, 1).getValues();
      
      const dates = raw.map(([cell]) => {
        const parsed = safeParseDate_(cell);
        return parsed;
      }).filter(Boolean);
      
      allDates.push(...dates);
      logTS(`Collected ${dates.length} dates from ${entry.sheetName}`);
    } catch (e) {
      logTS(`Error reading dates from ${entry.sheetName}: ${e}`);
    }
  });
  
  // Filter by retention policy
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - RESPONSE_RETENTION_DAYS);
  const cutoffStr = formatYMD_(cutoff);
  const filtered = allDates.filter(d => d >= cutoffStr);
  
  logTS(`getResponseDates:end - collected ${allDates.length} total, ${filtered.length} after retention filter`);
  return filtered;
}

/**
 * Tallies count of entries per date.
 * @param {string[]} dates - Array of date strings.
 * @return {Object.<string,number>} Map of date to count.
 */
function tallyByDate(dates) {
  logTS('tallyByDate:start');
  const counts = dates.reduce((m, d) => {
    m[d] = (m[d] || 0) + 1;
    return m;
  }, {});
  safeCachePut(CACHE_KEY, JSON.stringify(counts), 300);
  logTS('tallyByDate:end');
  return counts;
}

/**
 * Builds list of business days and form choice strings.
 * Limited to BUSINESS_DAYS_WINDOW actual business days (Mon-Fri).
 * @param {Object.<string,number>} counts - Map of date to booked count.
 * @return {{availDates:string[],choices:string[]}} Available dates and choice labels.
 */
function buildBusinessDays(counts) {
  logTS('buildBusinessDays:start');
  const items = [];
  const today = new Date();
  let businessDaysFound = 0;
  let dayOffset = 0;
  
  // Count actual business days up to BUSINESS_DAYS_WINDOW
  while (businessDaysFound < BUSINESS_DAYS_WINDOW) {
    const d = new Date(today);
    d.setDate(today.getDate() + dayOffset);
    const wd = d.getDay();
    
    // Skip weekends
    if (wd !== 0 && wd !== 6) {
      const key = DateUtils.formatYMD(d);
      // Skip holidays - prevent holiday dates from ever appearing in items
      if (HolidayService.isHoliday(key)) {
        logTS('buildBusinessDays: skipping holiday ' + key);
        dayOffset++;
        continue;
      }
      const used = counts[key] || 0;
      const left = SLOT_CAP - used;
      const weekday = Utilities.formatDate(d, TZ, 'EEE');
      
      // Only include dates with available slots
      if (left > 0) {
        const label = `${key} ${weekday} (${left} slot${left === 1 ? '' : 's'} left)`;
        items.push({ date: key, label: label, left: left });
      }
      
      businessDaysFound++;
    }
    
    dayOffset++;
    
    // Safety break to prevent infinite loop
    if (dayOffset > 100) break;
  }
  
  items.sort((a, b) => new Date(a.date) - new Date(b.date));
  const availDates = items.map(item => item.date);
  const choices = items.map(item => item.label);
  
  logTS('buildBusinessDays:end');
  return { availDates, choices };
}


/**
 * Syncs per-day summary calendar events.
 * @param {string[]} availDates - Dates to summarize.
 * @param {Object.<string,number>} counts - Map of date to booked count.
 */
function batchSyncCalendarSummaries(availDates, counts) {
  logTS('batchSyncCalendarSummaries:start');
  if (!availDates.length) {
    logTS('batchSyncCalendarSummaries:end');
    return;
  }
  // Use ONLY upsert helper for each date to ensure exactly one summary per date
  availDates.forEach(dateStr => {
    // Early exit on holidays before any summary creation
    if (HolidayService.isHoliday(dateStr)) {
      logTS('batchSyncCalendarSummaries: skipping holiday ' + dateStr);
      return;
    }
    const used = counts[dateStr] || 0;
    const left = SLOT_CAP - used;
    upsertDailySummary(dateStr, left);
  });
  
  // Validation: check for duplicate summaries and log anomalies
  availDates.forEach(dateStr => {
    const [y, m, d] = dateStr.split('-').map(Number);
    const dayDate = new Date(y, m - 1, d);
    const summaries = CAL.getEventsForDay(dayDate)
      .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
    
    if (summaries.length > 1) {
      logTS(`ANOMALY: Found ${summaries.length} summary events for ${dateStr}`);
    } else if (summaries.length === 0) {
      logTS(`ANOMALY: No summary event found for ${dateStr}`);
    }
  });
  
  logTS('batchSyncCalendarSummaries:end');
}

/**
 * Writes availability table into all availability sheets and applies color coding.
 * @param {string[]} availDates - Dates to write.
 * @param {Object.<string,number>} counts - Map of date to booked count.
 */
function batchWriteAvailabilitySheets(availDates, counts) {
  logTS('batchWriteAvailabilitySheets:start');
  
  FORM_REGISTRY.forEach(entry => {
    try {
      const ss = getSpreadsheetForEntry(entry);
      const sheet = getOrCreateSheetInSpreadsheet(ss, entry.availabilitySheetName);
      
      sheet.clearContents();
      const rows = [['Date', 'Booked', 'Slots Left']];
      availDates.forEach(dateStr => {
        const used = counts[dateStr] || 0;
        const left = SLOT_CAP - used;
        rows.push([dateStr, used, left]);
      });
      sheet.getRange(1, 1, rows.length, 3).setValues(rows);
      colorCodeAvailabilitySheet(sheet);
      logTS(`Updated availability sheet: ${entry.availabilitySheetName}`);
    } catch (e) {
      logTS(`Error updating availability sheet ${entry.availabilitySheetName}: ${e}`);
    }
  });
  
  logTS('batchWriteAvailabilitySheets:end');
}

/**
 * Generates a prefilled form URL for a specific date.
 * @param {string} dateText - Date string yyyy-MM-dd.
 * @param {Object} extraFields - Optional extra fields to prefill by field ID.
 * @param {string} formId - Optional form ID. Uses first form in registry if not provided.
 * @return {string} Prefilled form URL.
 */
function generatePrefillUrl(dateText, extraFields, formId) {
  logTS('generatePrefillUrl:start');
  try {
    // Use first form in registry if no formId provided
    const targetFormId = formId || FORM_REGISTRY[0].formId;
    const form = FormApp.openById(targetFormId);
    
    const d = DateUtils.parseDate(dateText);
    if (!d) {
      logTS(`generatePrefillUrl: Invalid date format: ${dateText}`);
      return form.getPublishedUrl();
    }
    const weekday = Utilities.formatDate(d, TZ, 'EEE');
    const li = getAppointmentListItem_(targetFormId);
    const choices = li.getChoices().map(c => c.getValue());
    
    // Find the matching choice for this date
    const matchingChoice = choices.find(choice => choice.startsWith(dateText));
    if (!matchingChoice) {
      logTS(`generatePrefillUrl: No choice found for date ${dateText}`);
      return form.getPublishedUrl();
    }
    
    // Create a prefilled response
    const response = form.createResponse();
    const listItemResponse = li.createResponse(matchingChoice);
    response.withItemResponse(listItemResponse);
    
    // Add extra fields if provided using dynamically generated field ID map
    if (extraFields) {
      // Generate fieldMap with actual form item IDs
      const fieldMap = {};
      const items = form.getItems();
      items.forEach(item => {
        const title = item.getTitle();
        const itemId = item.getId();
        
        // Map common field names to their IDs
        if (title.toLowerCase().includes('name') && !title.toLowerCase().includes('last') && !title.toLowerCase().includes('first')) {
          fieldMap['Name'] = itemId;
        } else if (title.toLowerCase().includes('last name')) {
          fieldMap['Last Name'] = itemId;
        } else if (title.toLowerCase().includes('first name')) {
          fieldMap['First Name'] = itemId;
        } else if (title.toLowerCase().includes('purok')) {
          fieldMap['Purok'] = itemId;
        } else if (title.toLowerCase().includes('barangay')) {
          fieldMap['Barangay'] = itemId;
        }
      });
      Object.entries(extraFields).forEach(([fieldName, value]) => {
        try {
          const itemId = fieldMap[fieldName];
          if (!itemId) return;
          const item = form.getItemById(itemId);
          if (!item) return;
          const itemType = item.getType();
          if (itemType === FormApp.ItemType.TEXT) {
            response.withItemResponse(item.asTextItem().createResponse(value));
          } else if (itemType === FormApp.ItemType.LIST) {
            response.withItemResponse(item.asListItem().createResponse(value));
          } else if (itemType === FormApp.ItemType.MULTIPLE_CHOICE) {
            response.withItemResponse(item.asMultipleChoiceItem().createResponse(value));
          }
        } catch (e) {
          logTS(`Error prefilling field ${fieldName}: ${e}`);
        }
      });
    }
    
    const prefillUrl = response.toPrefilledUrl();
    logTS('generatePrefillUrl:end');
    return prefillUrl;
  } catch (err) {
    logTS('Error in generatePrefillUrl: ' + err);
    const targetFormId = formId || FORM_REGISTRY[0].formId;
    const form = FormApp.openById(targetFormId);
    return form.getPublishedUrl();
  }
}

/**
 * Decrements the form choice count for a given date.
 * @param {string} dateText - Date string yyyy-MM-dd.
 * @param {string} formId - Optional form ID. Uses first form in registry if not provided.
 * @return {number} Remaining slots left.
 */
function decrementChoiceForDate(dateText, formId) {
  logTS('decrementChoiceForDate:start');
  try {
    const d = DateUtils.parseDate(dateText);
    if (!d) {
      logTS(`decrementChoiceForDate: Invalid date format: ${dateText}`);
      cachedListItems = {}; // Clear all cached list items
      return 0;
    }
    const weekday = Utilities.formatDate(d, TZ, 'EEE');
    const li = getAppointmentListItem_(formId);
    const raw = li.getChoices().map(c => c.getValue());
    let newLeft = 0;
    let found = false;
    const updated = raw.map(val => {
      if (val.startsWith(dateText)) {
        found = true;
        const m = val.match(/\((\d+)\s+slots?\s+left\)/);
        let left = m ? parseInt(m[1], 10) - 1 : SLOT_CAP - 1;
        if (left < 0) left = 0;
        newLeft = left;
        if (left > 0) {
          return `${dateText} ${weekday} (${left} slot${left === 1 ? '' : 's'} left)`;
        } else {
          // Remove fully booked dates from choices
          return null;
        }
      }
      return val;
    }).filter(val => val !== null);
    
    if (!found) {
      logTS(`decrementChoiceForDate: Date ${dateText} not found in choices for form ${formId || 'default'}`);
      cachedListItems = {}; // Clear all cached list items
      return 0;
    }
    li.setChoiceValues(updated);
    logTS('decrementChoiceForDate:end');
    return newLeft;
  } catch (err) {
    logTS('Error in decrementChoiceForDate: ' + err);
    return 0;
  }
}

/**
 * Ensures exactly one summary event exists for a given date with correct title and color.
 * This is the SOLE function responsible for creating/updating summary events.
 * Updates existing event or creates new one if missing. Deletes any duplicates.
 * Uses script lock to prevent race conditions from parallel execution.
 * @param {string} dateText - Date string yyyy-MM-dd.
 * @param {number} left - Slots left.
 */
function upsertDailySummary(dateText, left) {
  logTS(`upsertDailySummary:start for ${dateText}, ${left} slots left`);
  
  // Holiday guard: immediately return if holiday - prevent any event creation/modification
  if (HolidayService.isHoliday(dateText)) {
    logTS('upsertDailySummary: early exit on holiday ' + dateText);
    return;
  }
  
  // Acquire lock to prevent race conditions
  let lock = LockService.getScriptLock();
  if (!lock.tryLock(LOCK_TIMEOUT_MS)) {
    logTS(`upsertDailySummary: Lock busy for ${dateText}, skipping`);
    return;
  }
  
  try {
    const [y, m, d] = dateText.split('-').map(Number);
    const start = new Date(y, m - 1, d);
    
    // Fetch all existing summary events for this day
    const summaries = CAL.getEventsForDay(start)
       .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
    
    const title = left > 0 ? `${left} Slots left (${SLOT_CAP} total)` : `Fully booked`;
    const color = left > 0 ? EVENT_COLOR_AVAILABLE : EVENT_COLOR_FULL;
    
    if (summaries.length > 0) {
      // Update the first existing summary
      summaries[0].setTitle(title);
      summaries[0].setColor(color);
      logTS(`Updated existing summary for ${dateText}`);
      
      // Delete any additional summaries to enforce uniqueness
      if (summaries.length > 1) {
        logTS(`Removing ${summaries.length - 1} duplicate summaries for ${dateText}`);
        for (let i = 1; i < summaries.length; i++) {
          summaries[i].deleteEvent();
        }
      }
    } else {
      // Create new summary if none exists - this is the ONLY place summaries are created
      const ev = CAL.createAllDayEvent(title, start, { description: FULL_SUMMARY_TAG });
      ev.setColor(color);
      logTS(`Created new summary for ${dateText}`);
    }
  } finally {
    lock.releaseLock();
  }
  
  logTS(`upsertDailySummary:end for ${dateText}`);
}

/**
 * Performs a micro sync for a specific date: updates counts, dropdowns, calendar summary, sheet row, and cache.
 * @param {string} dateText - Date string yyyy-MM-dd.
 * @param {string} formId - Form ID to update dropdown for.
 */
function microSyncForDate(dateText, formId) {
  logTS(`microSyncForDate:start for ${dateText}`);
  
  // Input validation
  if (!formId || !dateText) {
    logTS('microSyncForDate: missing required parameters, returning early');
    return;
  }
  
  if (HolidayService.isHoliday(dateText)) {
    logTS('microSyncForDate: early exit on holiday ' + dateText);
    return;
  }
  const dates = getResponseDates();
  const counts = tallyByDate(dates);
  const used = counts[dateText] || 0;
  const left = SLOT_CAP - used;
  const { choices } = buildBusinessDays(counts);
  updateDateDropdownForForm(formId, choices);
  upsertDailySummary(dateText, left);
  updateSheetRowForDate(dateText, left, formId);
  safeCacheRemove(CACHE_KEY);
  cachedCounts = null;
  logTS(`microSyncForDate:end for ${dateText}`);
}

/**
 * Updates availability for a single date only: decrements slots, updates summary, sheet row, and dropdown.
 * @param {string} dateText - Date string yyyy-MM-dd.
 * @param {string} formId - Form ID to update dropdown for.
 */
function updateAvailability_thisdateonly(dateText, formId) {
  logTS(`updateAvailability_thisdateonly:start for ${dateText}`);
  
  // Acquire lock to prevent race conditions
  let lock = LockService.getScriptLock();
  if (!lock.tryLock(LOCK_TIMEOUT_MS)) {
    logTS(`updateAvailability_thisdateonly: Lock busy for ${dateText}, skipping`);
    return;
  }
  
  try {
    // Input validation
    if (!formId || !dateText) {
      logTS('updateAvailability_thisdateonly: missing required parameters, returning early');
      return;
    }
    
    // Holiday guard: early exit on holidays
    if (HolidayService.isHoliday(dateText)) {
      logTS('updateAvailability_thisdateonly: early exit on holiday ' + dateText);
      return;
    }
    
    // Validate date format
    const testDate = DateUtils.parseDate(dateText);
    if (!testDate) {
      logTS('updateAvailability_thisdateonly: Invalid date format: ' + dateText);
      return;
    }
    
    // Count existing appointments for this date directly from calendar
    const usedCalendar = CAL.getEventsForDay(testDate).filter(ev => ev.getTitle().startsWith(TAG_APPOINTMENT)).length;
    const left = SLOT_CAP - usedCalendar;
    
    // Update calendar summary for this date
    upsertDailySummary(dateText, left);
    
    // Update sheet row for this date
    updateSheetRowForDate(dateText, left, formId);
    
    // Update dropdown for this form with fresh choices based on current counts
    try {
      const dates = getResponseDates();
      const counts = tallyByDate(dates);
      // Override the count for this specific date with the real-time calendar count
      counts[dateText] = usedCalendar;
      const { choices } = buildBusinessDays(counts);
      updateDateDropdownForForm(formId, choices);
    } catch (e) {
      logTS(`updateAvailability_thisdateonly: Error updating dropdown for form ${formId}: ${e}`);
    }
    
    // Clear cache to ensure compatibility with full-sync
    safeCacheRemove(CACHE_KEY);
    cachedCounts = null;
    
    logTS(`updateAvailability_thisdateonly:end for ${dateText}, ${left} slots left`);
  } finally {
    lock.releaseLock();
  }
}

/**
 * Updates the calendar summary event for a specific date.
 * @deprecated Use upsertDailySummary directly to avoid confusion
 * @param {string} dateText - Date string yyyy-MM-dd.
 * @param {number} left - Slots left.
 */
function updateCalendarSummaryForDate(dateText, left) {
  logTS('updateCalendarSummaryForDate:start (deprecated - use upsertDailySummary)');
  upsertDailySummary(dateText, left);
  logTS('updateCalendarSummaryForDate:end');
}

/**
 * Updates a single row in the availability sheet for a given date.
 * @param {string} dateText - Date string yyyy-MM-dd.
 * @param {number} left - Slots left.
 * @param {string} formId - Form ID to determine which entry's availability sheet to update.
 */
function updateSheetRowForDate(dateText, left, formId) {
  logTS('updateSheetRowForDate:start');
  
  if (!formId) {
    logTS('updateSheetRowForDate: No formId provided, updating all availability sheets');
    // Update all availability sheets if no specific form ID
    FORM_REGISTRY.forEach(entry => {
      updateSheetRowForEntry(dateText, left, entry);
    });
    return;
  }
  
  try {
    const entry = FORM_REGISTRY.find(e => e.formId === formId);
    if (!entry) {
      logTS(`updateSheetRowForDate: Form ID ${formId} not found in registry`);
      return;
    }
    
    updateSheetRowForEntry(dateText, left, entry);
  } catch (err) {
    logTS('Error in updateSheetRowForDate: ' + err);
    throw err;
  }
  logTS('updateSheetRowForDate:end');
}

/**
 * Updates a single row in the availability sheet for a specific entry.
 * @param {string} dateText - Date string yyyy-MM-dd.
 * @param {number} left - Slots left.
 * @param {Object} entry - Registry entry.
 */
function updateSheetRowForEntry(dateText, left, entry) {
  try {
    const ss = getSpreadsheetForEntry(entry);
    const sheet = getOrCreateSheetInSpreadsheet(ss, entry.availabilitySheetName);
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) {
      logTS(`updateSheetRowForEntry: No data rows found in ${entry.availabilitySheetName}`);
      return;
    }
    
    // Use dynamic column detection instead of hardcoded header lookup
    let dateIdx, bookedIdx, leftIdx;
    try {
      dateIdx = detectColumnIndex_(sheet, 'Date');
      bookedIdx = detectColumnIndex_(sheet, 'Booked');
      leftIdx = detectColumnIndex_(sheet, 'Slots Left');
    } catch (e) {
      logTS(`updateSheetRowForEntry: Missing required headers in ${entry.availabilitySheetName}: ${e}`);
      return;
    }
    const data = sheet.getRange(2, dateIdx, lastRow - 1, 1).getValues();
    for (let i = 0; i < data.length; i++) {
      if (data[i][0] === dateText) {
        const rowNum = i + 2;
        sheet.getRange(rowNum, bookedIdx).setValue(SLOT_CAP - left);
        sheet.getRange(rowNum, leftIdx).setValue(left);
        break;
      }
    }
    sheet.sort({column: dateIdx, ascending: true});
    logTS(`Updated row for ${dateText} in ${entry.availabilitySheetName}`);
  } catch (e) {
    logTS(`Error updating sheet row for entry ${entry.availabilitySheetName}: ${e}`);
  }
}


/**
 * Detects the 1-based column index for a given header name in a sheet.
 * @param {Sheet} sheet - The sheet to search in.
 * @param {string} headerName - The header name to find.
 * @return {number} 1-based column index, or 0 if not found.
 * @throws {Error} If header is not found.
 */
function detectColumnIndex_(sheet, headerName) {
  try {
    const lastColumn = sheet.getLastColumn();
    if (lastColumn === 0) {
      throw new Error(`Sheet "${sheet.getName()}" has no columns`);
    }
    
    const headers = sheet.getRange(1, 1, 1, lastColumn).getValues()[0];
    const index = headers.indexOf(headerName);
    
    if (index === -1) {
      throw new Error(`Header "${headerName}" not found in sheet "${sheet.getName()}"`);
    }
    
    return index + 1; // Convert to 1-based index
  } catch (e) {
    logTS(`detectColumnIndex_ error for "${headerName}" in sheet "${sheet.getName()}": ${e}`);
    throw e;
  }
}

/**
 * Applies color-coding to availability sheet rows.
 * Red background if no slots left, green if slots available.
 * @param {Sheet} sheet - The sheet to apply color coding to.
 */
function colorCodeAvailabilitySheet(sheet) {
  logTS('colorCodeAvailabilitySheet:start');
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) {
    logTS('colorCodeAvailabilitySheet: No data rows to color');
    return;
  }
  const lastCol = sheet.getLastColumn();
  const dataRows = lastRow - 1; // Exclude header row
  
  // Get all "Slots Left" values at once using dynamic column detection
  let slotsLeftColIdx;
  try {
    slotsLeftColIdx = detectColumnIndex_(sheet, 'Slots Left');
  } catch (e) {
    logTS(`colorCodeAvailabilitySheet: Missing 'Slots Left' column: ${e}`);
    return;
  }
  const slotsLeftValues = sheet.getRange(2, slotsLeftColIdx, dataRows, 1).getValues();
  
  // Build 2D color matrix
  const colorsMatrix = [];
  for (let i = 0; i < dataRows; i++) {
    const left = slotsLeftValues[i][0];
    const color = left === 0 ? '#f4cccc' : '#d9ead3'; // Red if full, green if available
    // Create row array with same color for all columns
    const rowColors = new Array(lastCol).fill(color);
    colorsMatrix.push(rowColors);
  }
  
  // Apply all background colors in a single batch operation
  sheet.getRange(2, 1, dataRows, lastCol).setBackgrounds(colorsMatrix);
  logTS('colorCodeAvailabilitySheet:end');
}


// Optional test stubs for pure utility functions
function test_safeParseDate_valid() {
  if (safeParseDate_('2025-01-01') !== '2025-01-01') {
    throw new Error('safeParseDate_ failed for string date');
  }
  if (safeParseDate_(new Date('2025-01-01')) !== '2025-01-01') {
    throw new Error('safeParseDate_ failed for Date object');
  }
}

function test_safeParseDate_invalid() {
  if (safeParseDate_('invalid') !== null) {
    throw new Error('safeParseDate_ should return null for invalid string');
  }
  if (safeParseDate_(null) !== null) {
    throw new Error('safeParseDate_ should return null for null');
  }
  if (safeParseDate_(undefined) !== null) {
    throw new Error('safeParseDate_ should return null for undefined');
  }
}

function test_formatYMD_() {
  if (formatYMD_(new Date('2025-01-01')) !== '2025-01-01') {
    throw new Error('formatYMD_ failed for 2025-01-01');
  }
  if (formatYMD_(new Date('2025-12-31')) !== '2025-12-31') {
    throw new Error('formatYMD_ failed for 2025-12-31');
  }
}

function test_buildBusinessDays() {
  const counts = {'2025-01-01': 5, '2025-01-02': 20};
  const result = buildBusinessDays(counts);
  if (!Array.isArray(result.availDates)) {
    throw new Error('buildBusinessDays should return availDates array');
  }
  if (!Array.isArray(result.choices)) {
    throw new Error('buildBusinessDays should return choices array');
  }
  if (result.availDates.length !== result.choices.length) {
    throw new Error('availDates and choices should have same length');
  }
  
  // Assert that known holiday dates are never in availDates
  const knownHolidays = ['2025-12-25', '2025-01-01']; // Christmas and New Year
  knownHolidays.forEach(holiday => {
    if (result.availDates.includes(holiday)) {
      throw new Error('buildBusinessDays included holiday: ' + holiday);
    }
  });
}

function test_buildBusinessDays_excludesHolidays() {
  // Test that buildBusinessDays never includes known holidays in availDates
  const counts = {};
  const { availDates } = buildBusinessDays(counts);
  
  // Check against known Philippine holidays
  const knownHolidays = [
    '2025-12-25', // Christmas Day
    '2025-01-01', // New Year's Day
    '2025-06-12', // Independence Day
    '2025-12-30'  // Rizal Day
  ];
  
  knownHolidays.forEach(holiday => {
    if (availDates.includes(holiday)) {
      throw new Error('buildBusinessDays incorrectly included holiday: ' + holiday);
    }
  });
  
  logTS('test_buildBusinessDays_excludesHolidays: verified no holidays in availDates');
}

function test_HolidayService_calendarFallback() {
  // Test HolidayService fallback when CalendarApp fails
  const originalCalendarAvailable = HolidayService._calendarAvailable;
  const originalInit = HolidayService._initialized;
  
  try {
    // Force fallback mode
    HolidayService._calendarAvailable = false;
    HolidayService._initialized = true;
    
    const testStart = DateUtils.buildDate(2025, 1, 1);
    const testEnd = DateUtils.buildDate(2025, 1, 31);
    const holidays = HolidayService.fetchRange(testStart, testEnd);
    
    // Should include New Year's Day from manual rules
    if (!holidays.has('2025-01-01')) {
      throw new Error('HolidayService fallback failed to include New Year\'s Day');
    }
    
    logTS('test_HolidayService_calendarFallback: verified fallback works');
  } finally {
    // Restore original state
    HolidayService._calendarAvailable = originalCalendarAvailable;
    HolidayService._initialized = originalInit;
  }
}

function test_HolidayService_manualRules() {
  // Test manual holiday rules generation
  const testStart = DateUtils.buildDate(2025, 12, 20);
  const testEnd = DateUtils.buildDate(2025, 12, 31);
  
  // Force manual rules by simulating all other methods failed
  const originalCalendarAvailable = HolidayService._calendarAvailable;
  const originalInit = HolidayService._initialized;
  
  try {
    HolidayService._calendarAvailable = false;
    HolidayService._initialized = true;
    
    const holidays = HolidayService.fetchRange(testStart, testEnd);
    
    // Should include Christmas and Rizal Day
    if (!holidays.has('2025-12-25')) {
      throw new Error('Manual rules failed to include Christmas Day');
    }
    if (!holidays.has('2025-12-30')) {
      throw new Error('Manual rules failed to include Rizal Day');
    }
    
    logTS('test_HolidayService_manualRules: verified manual rules work');
  } finally {
    HolidayService._calendarAvailable = originalCalendarAvailable;
    HolidayService._initialized = originalInit;
  }
}

function test_DateUtils_buildAndFormat() {
  // Test DateUtils date building and formatting
  const testDate = DateUtils.buildDate(2025, 1, 15);
  const formatted = DateUtils.formatYMD(testDate);
  
  if (formatted !== '2025-01-15') {
    throw new Error('DateUtils formatting failed: expected 2025-01-15, got ' + formatted);
  }
  
  const parsed = DateUtils.parseDate('2025-01-15');
  if (!parsed || DateUtils.formatYMD(parsed) !== '2025-01-15') {
    throw new Error('DateUtils parsing failed');
  }
  
  logTS('test_DateUtils_buildAndFormat: verified date utilities work');
}

function test_HolidayService_cacheKeys() {
  // Test that HolidayService generates unique cache keys per range
  const start1 = DateUtils.buildDate(2025, 1, 1);
  const end1 = DateUtils.buildDate(2025, 1, 31);
  const start2 = DateUtils.buildDate(2025, 2, 1);
  const end2 = DateUtils.buildDate(2025, 2, 28);
  
  // Clear any existing cache
  const key1 = `${SCRIPT_VERSION}_holidays_2025-01-01_2025-01-31`;
  const key2 = `${SCRIPT_VERSION}_holidays_2025-02-01_2025-02-28`;
  safeCacheRemove(key1);
  safeCacheRemove(key2);
  
  // Fetch ranges to populate cache
  HolidayService.fetchRange(start1, end1);
  HolidayService.fetchRange(start2, end2);
  
  // Verify different cache keys were used
  const cached1 = safeCacheGet(key1);
  const cached2 = safeCacheGet(key2);
  
  if (!cached1) {
    throw new Error('HolidayService failed to cache first range');
  }
  if (!cached2) {
    throw new Error('HolidayService failed to cache second range');
  }
  
  logTS('test_HolidayService_cacheKeys: verified unique cache keys per range');
}

function test_tallyByDate_cache() {
  safeCacheRemove(CACHE_KEY);
  const testDates = ['2025-01-01', '2025-01-01', '2025-01-02'];
  const result = tallyByDate(testDates);
  const cached = safeCacheGet(CACHE_KEY);
  if (!cached) {
    throw new Error('tallyByDate should cache results');
  }
  const parsedCache = JSON.parse(cached);
  if (parsedCache['2025-01-01'] !== 2 || parsedCache['2025-01-02'] !== 1) {
    throw new Error('cached tally results incorrect');
  }
}

function test_assignColor() {
  const availableColor = 5 > 0 ? EVENT_COLOR_AVAILABLE : EVENT_COLOR_FULL;
  const fullColor = 0 > 0 ? EVENT_COLOR_AVAILABLE : EVENT_COLOR_FULL;
  if (availableColor !== EVENT_COLOR_AVAILABLE) {
    throw new Error('assignColor should return EVENT_COLOR_AVAILABLE when slots left > 0');
  }
  if (fullColor !== EVENT_COLOR_FULL) {
    throw new Error('assignColor should return EVENT_COLOR_FULL when slots left === 0');
  }
}

function test_summaryUniqueness() {
  // Test that upsertDailySummary ensures exactly one summary per date
  const testDate = '2025-01-01';
  
  // First call should create summary
  upsertDailySummary(testDate, 19);
  let evs = CAL.getEventsForDay(new Date(2025,0,1))
    .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG)===0);
  if (evs.length !== 1) throw new Error('Expected single summary after first call, found '+evs.length);
  
  // Second call should update existing, not create duplicate
  upsertDailySummary(testDate, 18);
  evs = CAL.getEventsForDay(new Date(2025,0,1))
    .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG)===0);
  if (evs.length !== 1) throw new Error('Expected single summary after second call, found '+evs.length);
  
  // Verify title was updated
  if (!evs[0].getTitle().includes('18 Slots left')) {
    throw new Error('Summary title was not updated correctly');
  }
}

function test_holidaysExcluded() {
  // Ensure buildBusinessDays does not include known holiday dates
  const counts = {};
  const holidayDate = '2025-12-25';
  const { availDates } = buildBusinessDays(counts);
  if (availDates.includes(holidayDate)) {
    throw new Error('buildBusinessDays included holiday: ' + holidayDate);
  }
}

function test_holidayGuardOnSubmit() {
  // Simulate a form submission on a holiday and expect early return with no booking or summary event
  const holidayDate = '2025-12-25';
  
  // Create proper namedValues structure and mock source
  const e = {
    namedValues: {
      'Last Name': ['TestLastName'],
      'First Name': ['TestFirstName'],
      'Purok': ['TestPurok'],
      'Barangay': ['TestBarangay'],
      'Date of Appointment': [holidayDate + ' Mon (20 slots left)']
    },
    source: {
      getId: function() {
        return FORM_REGISTRY[0].formId; // Use first form in registry
      }
    }
  };
  
  let rejected = false;
  const originalLogTS = logTS;
  logTS = function(msg) {
    if (msg.indexOf('booking on holiday rejected') >= 0) {
      rejected = true;
    }
  };
  
  onFormSubmit(e);
  logTS = originalLogTS;
  
  if (!rejected) {
    throw new Error('onFormSubmit did not reject booking on holiday');
  }
  
  // Verify no appointment or summary events were created on the holiday
  const [y, m, d] = holidayDate.split('-').map(Number);
  const testDate = DateUtils.buildDate(y, m, d);
  const dayEvents = CAL.getEventsForDay(testDate);
  const appointments = dayEvents.filter(ev => ev.getTitle().startsWith(TAG_APPOINTMENT));
  const summaries = dayEvents.filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
  
  if (appointments.length > 0) {
    throw new Error('onFormSubmit created appointment event on holiday');
  }
  if (summaries.length > 0) {
    throw new Error('onFormSubmit created summary event on holiday');
  }
}

function test_upsertDailySummary_holiday() {
  // Assert that calling upsertDailySummary on a holiday never creates or updates events
  const holidayDate = '2025-12-25';
  const [y, m, d] = holidayDate.split('-').map(Number);
  const testDate = DateUtils.buildDate(y, m, d);
  
  // Ensure no existing events on the holiday
  const existingEvents = CAL.getEventsForDay(testDate);
  existingEvents.forEach(ev => ev.deleteEvent());
  
  // Call upsertDailySummary on holiday
  upsertDailySummary(holidayDate, 15);
  
  // Verify no summary event was created
  const summaries = CAL.getEventsForDay(testDate)
    .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
  if (summaries.length !== 0) {
    throw new Error('upsertDailySummary created summary event on holiday');
  }
}

function test_removeHolidaySummaries() {
  // Test that removeHolidaySummaries deletes both summary and appointment events on holiday dates
  const holidayDate = '2025-12-25';
  const [y, m, d] = holidayDate.split('-').map(Number);
  const testDate = DateUtils.buildDate(y, m, d);
  
  // Create dummy summary and appointment events on the holiday
  const dummySummary = CAL.createAllDayEvent('Test Holiday Summary', testDate, { 
    description: FULL_SUMMARY_TAG 
  });
  const dummyAppointment = CAL.createAllDayEvent(TAG_APPOINTMENT + ' Test Holiday Appointment', testDate);
  
  // Verify the events were created
  let summaries = CAL.getEventsForDay(testDate)
    .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
  let appointments = CAL.getEventsForDay(testDate)
    .filter(ev => ev.getTitle().startsWith(TAG_APPOINTMENT));
  if (summaries.length !== 1 || appointments.length !== 1) {
    throw new Error('Failed to create test holiday events');
  }
  
  // Call removeHolidaySummaries
  const startDate = new Date(testDate.getTime() - 86400000); // day before
  const endDate = new Date(testDate.getTime() + 86400000);   // day after
  removeHolidaySummaries(startDate, endDate);
  
  // Verify both holiday summary and appointment were removed
  summaries = CAL.getEventsForDay(testDate)
    .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
  appointments = CAL.getEventsForDay(testDate)
    .filter(ev => ev.getTitle().startsWith(TAG_APPOINTMENT));
  if (summaries.length !== 0) {
    throw new Error('removeHolidaySummaries failed to delete holiday summary');
  }
  if (appointments.length !== 0) {
    throw new Error('removeHolidaySummaries failed to delete holiday appointment');
  }
}

function test_colorMappingNormalization() {
  // Test that all appointment events use the default available color
  const testColor = EVENT_COLOR_AVAILABLE;
  if (!Object.values(CalendarApp.EventColor).includes(testColor)) {
    throw new Error('Invalid default color: ' + testColor);
  }
  logTS('test_colorMappingNormalization: verified default color is valid');
}

function test_updateAvailabilityThisDateOnly() {
  // Test that updateAvailability_thisdateonly performs targeted updates for a single date
  const testDate = '2025-01-15';
  const testFormId = FORM_REGISTRY[0].formId;
  
  // Setup: ensure test date has available slots
  try {
    const li = getAppointmentListItem_(testFormId);
    const testChoice = `${testDate} Wed (5 slots left)`;
    li.setChoiceValues([testChoice]);
  } catch (e) {
    logTS('test_updateAvailabilityThisDateOnly: setup failed: ' + e);
    return;
  }
  
  // Record initial state
  const initialChoices = getAppointmentListItem_(testFormId).getChoices().map(c => c.getValue());
  const initialSlots = initialChoices.find(c => c.startsWith(testDate));
  const initialSlotsMatch = initialSlots ? initialSlots.match(/\((\d+)\s+slots?\s+left\)/) : null;
  const initialSlotsLeft = initialSlotsMatch ? parseInt(initialSlotsMatch[1], 10) : 0;
  
  if (initialSlotsLeft === 0) {
    logTS('test_updateAvailabilityThisDateOnly: test date has no slots, skipping');
    return;
  }
  
  // Call the function
  updateAvailability_thisdateonly(testDate, testFormId);
  
  // Verify slot decrement in dropdown
  const updatedChoices = getAppointmentListItem_(testFormId).getChoices().map(c => c.getValue());
  const updatedSlots = updatedChoices.find(c => c.startsWith(testDate));
  
  if (initialSlotsLeft > 1) {
    // Should still have choices but with decremented count
    if (!updatedSlots) {
      throw new Error('test_updateAvailabilityThisDateOnly: choice disappeared when slots should remain');
    }
    const updatedSlotsMatch = updatedSlots.match(/\((\d+)\s+slots?\s+left\)/);
    const updatedSlotsLeft = updatedSlotsMatch ? parseInt(updatedSlotsMatch[1], 10) : 0;
    if (updatedSlotsLeft !== initialSlotsLeft - 1) {
      throw new Error(`test_updateAvailabilityThisDateOnly: expected ${initialSlotsLeft - 1} slots, got ${updatedSlotsLeft}`);
    }
  } else {
    // Should remove choice when fully booked
    if (updatedSlots) {
      throw new Error('test_updateAvailabilityThisDateOnly: choice should be removed when fully booked');
    }
  }
  
  // Verify summary event was updated
  const [y, m, d] = testDate.split('-').map(Number);
  const dayDate = new Date(y, m - 1, d);
  const summaries = CAL.getEventsForDay(dayDate)
    .filter(ev => ev.getDescription().indexOf(FULL_SUMMARY_TAG) === 0);
  
  if (summaries.length !== 1) {
    throw new Error(`test_updateAvailabilityThisDateOnly: expected 1 summary event, found ${summaries.length}`);
  }
  
  const expectedSlotsLeft = Math.max(0, initialSlotsLeft - 1);
  const summaryTitle = summaries[0].getTitle();
  if (expectedSlotsLeft > 0) {
    if (!summaryTitle.includes(`${expectedSlotsLeft} Slots left`)) {
      throw new Error(`test_updateAvailabilityThisDateOnly: summary title incorrect: ${summaryTitle}`);
    }
  } else {
    if (!summaryTitle.includes('Fully booked')) {
      throw new Error(`test_updateAvailabilityThisDateOnly: summary should show fully booked: ${summaryTitle}`);
    }
  }
  
  logTS('test_updateAvailabilityThisDateOnly: verified targeted date-only updates work correctly');
}

/**
 * Runs all test functions and logs results.
 */
function runTests() {
  const testFunctions = [
    { name: 'test_safeParseDate_valid', fn: test_safeParseDate_valid },
    { name: 'test_safeParseDate_invalid', fn: test_safeParseDate_invalid },
    { name: 'test_formatYMD_', fn: test_formatYMD_ },
    { name: 'test_buildBusinessDays', fn: test_buildBusinessDays },
    { name: 'test_buildBusinessDays_excludesHolidays', fn: test_buildBusinessDays_excludesHolidays },
    { name: 'test_tallyByDate_cache', fn: test_tallyByDate_cache },
    { name: 'test_assignColor', fn: test_assignColor },
    { name: 'test_summaryUniqueness', fn: test_summaryUniqueness },
    { name: 'test_holidaysExcluded', fn: test_holidaysExcluded },
    { name: 'test_holidayGuardOnSubmit', fn: test_holidayGuardOnSubmit },
    { name: 'test_upsertDailySummary_holiday', fn: test_upsertDailySummary_holiday },
    { name: 'test_removeHolidaySummaries', fn: test_removeHolidaySummaries },
    { name: 'test_HolidayService_calendarFallback', fn: test_HolidayService_calendarFallback },
    { name: 'test_HolidayService_manualRules', fn: test_HolidayService_manualRules },
    { name: 'test_DateUtils_buildAndFormat', fn: test_DateUtils_buildAndFormat },
    { name: 'test_HolidayService_cacheKeys', fn: test_HolidayService_cacheKeys },
    { name: 'test_colorMappingNormalization', fn: test_colorMappingNormalization },
    { name: 'test_updateAvailabilityThisDateOnly', fn: test_updateAvailabilityThisDateOnly }
  ];
  
  testFunctions.forEach(test => {
    try {
      test.fn();
      logTS('PASS: ' + test.name);
    } catch (e) {
      logTS('FAIL: ' + test.name + ' — ' + e);
    }
  });
  
  logTS('runTests complete');
}

/**
 * Ensures a daily trigger exists for the runTests function.
 * Creates one if it doesn't already exist.
 */
function ensureTestTriggerExists() {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    const existingTrigger = triggers.find(trigger => 
      trigger.getHandlerFunction() === 'runTests' &&
      trigger.getEventType() === ScriptApp.EventType.CLOCK
    );
    
    if (!existingTrigger) {
      ScriptApp.newTrigger('runTests')
        .timeBased()
        .everyDays(1)
        .create();
      logTS('Created daily trigger for runTests');
    } else {
      logTS('Daily trigger for runTests already exists');
    }
  } catch (e) {
    logTS('Error in ensureTestTriggerExists: ' + e);
  }
}

/**
 * Ensures time-based triggers exist for sync functions.
 * Creates daily trigger for updateAvailability_everywhere and hourly trigger for checkCalendarIntegrity.
 */
function ensureSyncTriggersExists() {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    
    // Check for existing updateAvailability_everywhere trigger
    const existingDailySync = triggers.find(trigger => 
      trigger.getHandlerFunction() === 'updateAvailability_everywhere' &&
      trigger.getEventType() === ScriptApp.EventType.CLOCK
    );
    
    if (!existingDailySync) {
      ScriptApp.newTrigger('updateAvailability_everywhere')
        .timeBased()
        .everyDays(1)
        .create();
      logTS('Created daily trigger for updateAvailability_everywhere');
    } else {
      logTS('Daily trigger for updateAvailability_everywhere already exists');
    }
    
    // Check for existing checkCalendarIntegrity trigger
    const existingHourlyIntegrity = triggers.find(trigger => 
      trigger.getHandlerFunction() === 'checkCalendarIntegrity' &&
      trigger.getEventType() === ScriptApp.EventType.CLOCK
    );
    
    if (!existingHourlyIntegrity) {
      ScriptApp.newTrigger('checkCalendarIntegrity')
        .timeBased()
        .everyHours(1)
        .create();
      logTS('Created hourly trigger for checkCalendarIntegrity');
    } else {
      logTS('Hourly trigger for checkCalendarIntegrity already exists');
    }
  } catch (e) {
    logTS('Error in ensureSyncTriggersExists: ' + e);
  }
}

/**
 * Install hook to set up triggers when the script is installed.
 * @param {Object} e - Install event object.
 */
function onInstall(e) {
  runSetup();
  ensureTestTriggerExists();
  ensureSyncTriggersExists();
}

/**
 * Open hook to ensure triggers are set up when the script is opened.
 * @param {Object} e - Open event object.
 */
function onOpen(e) {
  runSetup();
  ensureTestTriggerExists();
  ensureSyncTriggersExists();
}
